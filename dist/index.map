{"version":3,"sources":["../node_modules/superfine/src/index.js","libs/model.js","../node_modules/url-mapper/mapper.js","../node_modules/urlon/lib/urlon.js","../node_modules/path-to-regexp/index.js","../node_modules/url-mapper/compileRoute.js","../node_modules/url-mapper/index.js","libs/router.js","index.js"],"names":["DEFAULT","RECYCLED_NODE","TEXT_NODE","XLINK_NS","SVG_NS","EMPTY_OBJECT","EMPTY_ARRAY","map","isArray","Array","merge","a","b","target","i","eventProxy","event","currentTarget","events","type","updateProperty","element","name","lastValue","nextValue","isSvg","style","setProperty","slice","removeEventListener","addEventListener","nullOrFalse","removeAttribute","replace","removeAttributeNS","setAttributeNS","setAttribute","createElement","node","lifecycle","document","createTextNode","createElementNS","props","oncreate","push","length","children","appendChild","updateElement","lastProps","nextProps","isRecycled","cb","onupdate","removeChildren","ondestroy","removeElement","parent","remove","removeChild","onremove","getKey","key","createKeyMap","start","end","out","patchElement","lastNode","nextNode","nodeValue","newElement","insertBefore","savedNode","childNode","lastKey","nextChStart","lastChildren","nextKey","lastChStart","lastChEnd","nextChildren","nextChEnd","lastKeyed","nextKeyed","createVNode","createTextVNode","text","recycleChild","nodeType","recycleElement","nodeName","toLowerCase","call","childNodes","recycle","container","patch","pop","h","rest","arguments","Observable","dataObj","signals","Dep","subs","depend","deps","dep","includes","getValidDeps","filter","notifyDeps","sig","notify","observe","property","makeReactive","obj","computeFunc","val","Object","defineProperty","get","set","newVal","console","log","signal","lenght","forEach","signalHandler","makeComputed","cache","hasOwnProperty","observeData","data","watchers","context","bind","subscribeWatchers","watch","state","module","exports","urlMapper","router","routes","loc","matchedRoute","Render","view","Router"],"mappings":"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","file":"index.map","sourceRoot":"..\\src","sourcesContent":["var DEFAULT = 0\nvar RECYCLED_NODE = 1\nvar TEXT_NODE = 2\n\nvar XLINK_NS = \"http://www.w3.org/1999/xlink\"\nvar SVG_NS = \"http://www.w3.org/2000/svg\"\n\nvar EMPTY_OBJECT = {}\nvar EMPTY_ARRAY = []\n\nvar map = EMPTY_ARRAY.map\nvar isArray = Array.isArray\n\nvar merge = function(a, b) {\n  var target = {}\n\n  for (var i in a) target[i] = a[i]\n  for (var i in b) target[i] = b[i]\n\n  return target\n}\n\nvar eventProxy = function(event) {\n  return event.currentTarget.events[event.type](event)\n}\n\nvar updateProperty = function(element, name, lastValue, nextValue, isSvg) {\n  if (name === \"key\") {\n  } else if (name === \"style\") {\n    for (var i in merge(lastValue, nextValue)) {\n      var style = nextValue == null || nextValue[i] == null ? \"\" : nextValue[i]\n      if (i[0] === \"-\") {\n        element[name].setProperty(i, style)\n      } else {\n        element[name][i] = style\n      }\n    }\n  } else {\n    if (name[0] === \"o\" && name[1] === \"n\") {\n      if (!element.events) element.events = {}\n\n      element.events[(name = name.slice(2))] = nextValue\n\n      if (nextValue == null) {\n        element.removeEventListener(name, eventProxy)\n      } else if (lastValue == null) {\n        element.addEventListener(name, eventProxy)\n      }\n    } else {\n      var nullOrFalse = nextValue == null || nextValue === false\n\n      if (\n        name in element &&\n        name !== \"list\" &&\n        name !== \"draggable\" &&\n        name !== \"spellcheck\" &&\n        name !== \"translate\" &&\n        !isSvg\n      ) {\n        element[name] = nextValue == null ? \"\" : nextValue\n        if (nullOrFalse) {\n          element.removeAttribute(name)\n        }\n      } else {\n        var ns = isSvg && name !== (name = name.replace(/^xlink:?/, \"\"))\n        if (ns) {\n          if (nullOrFalse) {\n            element.removeAttributeNS(XLINK_NS, name)\n          } else {\n            element.setAttributeNS(XLINK_NS, name, nextValue)\n          }\n        } else {\n          if (nullOrFalse) {\n            element.removeAttribute(name)\n          } else {\n            element.setAttribute(name, nextValue)\n          }\n        }\n      }\n    }\n  }\n}\n\nvar createElement = function(node, lifecycle, isSvg) {\n  var element =\n    node.type === TEXT_NODE\n      ? document.createTextNode(node.name)\n      : (isSvg = isSvg || node.name === \"svg\")\n        ? document.createElementNS(SVG_NS, node.name)\n        : document.createElement(node.name)\n\n  var props = node.props\n  if (props.oncreate) {\n    lifecycle.push(function() {\n      props.oncreate(element)\n    })\n  }\n\n  for (var i = 0, length = node.children.length; i < length; i++) {\n    element.appendChild(createElement(node.children[i], lifecycle, isSvg))\n  }\n\n  for (var name in props) {\n    updateProperty(element, name, null, props[name], isSvg)\n  }\n\n  return (node.element = element)\n}\n\nvar updateElement = function(\n  element,\n  lastProps,\n  nextProps,\n  lifecycle,\n  isSvg,\n  isRecycled\n) {\n  for (var name in merge(lastProps, nextProps)) {\n    if (\n      (name === \"value\" || name === \"checked\"\n        ? element[name]\n        : lastProps[name]) !== nextProps[name]\n    ) {\n      updateProperty(element, name, lastProps[name], nextProps[name], isSvg)\n    }\n  }\n\n  var cb = isRecycled ? nextProps.oncreate : nextProps.onupdate\n  if (cb != null) {\n    lifecycle.push(function() {\n      cb(element, lastProps)\n    })\n  }\n}\n\nvar removeChildren = function(node) {\n  for (var i = 0, length = node.children.length; i < length; i++) {\n    removeChildren(node.children[i])\n  }\n\n  var cb = node.props.ondestroy\n  if (cb != null) {\n    cb(node.element)\n  }\n\n  return node.element\n}\n\nvar removeElement = function(parent, node) {\n  var remove = function() {\n    parent.removeChild(removeChildren(node))\n  }\n\n  var cb = node.props && node.props.onremove\n  if (cb != null) {\n    cb(node.element, remove)\n  } else {\n    remove()\n  }\n}\n\nvar getKey = function(node) {\n  return node == null ? null : node.key\n}\n\nvar createKeyMap = function(children, start, end) {\n  var out = {}\n  var key\n  var node\n\n  for (; start <= end; start++) {\n    if ((key = (node = children[start]).key) != null) {\n      out[key] = node\n    }\n  }\n\n  return out\n}\n\nvar patchElement = function(\n  parent,\n  element,\n  lastNode,\n  nextNode,\n  lifecycle,\n  isSvg\n) {\n  if (nextNode === lastNode) {\n  } else if (\n    lastNode != null &&\n    lastNode.type === TEXT_NODE &&\n    nextNode.type === TEXT_NODE\n  ) {\n    if (lastNode.name !== nextNode.name) {\n      element.nodeValue = nextNode.name\n    }\n  } else if (lastNode == null || lastNode.name !== nextNode.name) {\n    var newElement = parent.insertBefore(\n      createElement(nextNode, lifecycle, isSvg),\n      element\n    )\n\n    if (lastNode != null) removeElement(parent, lastNode)\n\n    element = newElement\n  } else {\n    updateElement(\n      element,\n      lastNode.props,\n      nextNode.props,\n      lifecycle,\n      (isSvg = isSvg || nextNode.name === \"svg\"),\n      lastNode.type === RECYCLED_NODE\n    )\n\n    var savedNode\n    var childNode\n\n    var lastKey\n    var lastChildren = lastNode.children\n    var lastChStart = 0\n    var lastChEnd = lastChildren.length - 1\n\n    var nextKey\n    var nextChildren = nextNode.children\n    var nextChStart = 0\n    var nextChEnd = nextChildren.length - 1\n\n    while (nextChStart <= nextChEnd && lastChStart <= lastChEnd) {\n      lastKey = getKey(lastChildren[lastChStart])\n      nextKey = getKey(nextChildren[nextChStart])\n\n      if (lastKey == null || lastKey !== nextKey) break\n\n      patchElement(\n        element,\n        lastChildren[lastChStart].element,\n        lastChildren[lastChStart],\n        nextChildren[nextChStart],\n        lifecycle,\n        isSvg\n      )\n\n      lastChStart++\n      nextChStart++\n    }\n\n    while (nextChStart <= nextChEnd && lastChStart <= lastChEnd) {\n      lastKey = getKey(lastChildren[lastChEnd])\n      nextKey = getKey(nextChildren[nextChEnd])\n\n      if (lastKey == null || lastKey !== nextKey) break\n\n      patchElement(\n        element,\n        lastChildren[lastChEnd].element,\n        lastChildren[lastChEnd],\n        nextChildren[nextChEnd],\n        lifecycle,\n        isSvg\n      )\n\n      lastChEnd--\n      nextChEnd--\n    }\n\n    if (lastChStart > lastChEnd) {\n      while (nextChStart <= nextChEnd) {\n        element.insertBefore(\n          createElement(nextChildren[nextChStart++], lifecycle, isSvg),\n          (childNode = lastChildren[lastChStart]) && childNode.element\n        )\n      }\n    } else if (nextChStart > nextChEnd) {\n      while (lastChStart <= lastChEnd) {\n        removeElement(element, lastChildren[lastChStart++])\n      }\n    } else {\n      var lastKeyed = createKeyMap(lastChildren, lastChStart, lastChEnd)\n      var nextKeyed = {}\n\n      while (nextChStart <= nextChEnd) {\n        lastKey = getKey((childNode = lastChildren[lastChStart]))\n        nextKey = getKey(nextChildren[nextChStart])\n\n        if (\n          nextKeyed[lastKey] ||\n          (nextKey != null && nextKey === getKey(lastChildren[lastChStart + 1]))\n        ) {\n          if (lastKey == null) {\n            removeElement(element, childNode)\n          }\n          lastChStart++\n          continue\n        }\n\n        if (nextKey == null || lastNode.type === RECYCLED_NODE) {\n          if (lastKey == null) {\n            patchElement(\n              element,\n              childNode && childNode.element,\n              childNode,\n              nextChildren[nextChStart],\n              lifecycle,\n              isSvg\n            )\n            nextChStart++\n          }\n          lastChStart++\n        } else {\n          if (lastKey === nextKey) {\n            patchElement(\n              element,\n              childNode.element,\n              childNode,\n              nextChildren[nextChStart],\n              lifecycle,\n              isSvg\n            )\n            nextKeyed[nextKey] = true\n            lastChStart++\n          } else {\n            if ((savedNode = lastKeyed[nextKey]) != null) {\n              patchElement(\n                element,\n                element.insertBefore(\n                  savedNode.element,\n                  childNode && childNode.element\n                ),\n                savedNode,\n                nextChildren[nextChStart],\n                lifecycle,\n                isSvg\n              )\n              nextKeyed[nextKey] = true\n            } else {\n              patchElement(\n                element,\n                childNode && childNode.element,\n                null,\n                nextChildren[nextChStart],\n                lifecycle,\n                isSvg\n              )\n            }\n          }\n          nextChStart++\n        }\n      }\n\n      while (lastChStart <= lastChEnd) {\n        if (getKey((childNode = lastChildren[lastChStart++])) == null) {\n          removeElement(element, childNode)\n        }\n      }\n\n      for (var key in lastKeyed) {\n        if (nextKeyed[key] == null) {\n          removeElement(element, lastKeyed[key])\n        }\n      }\n    }\n  }\n\n  return (nextNode.element = element)\n}\n\nvar createVNode = function(name, props, children, element, key, type) {\n  return {\n    name: name,\n    props: props,\n    children: children,\n    element: element,\n    key: key,\n    type: type\n  }\n}\n\nvar createTextVNode = function(text, element) {\n  return createVNode(text, EMPTY_OBJECT, EMPTY_ARRAY, element, null, TEXT_NODE)\n}\n\nvar recycleChild = function(element) {\n  return element.nodeType === 3 // Node.TEXT_NODE\n    ? createTextVNode(element.nodeValue, element)\n    : recycleElement(element)\n}\n\nvar recycleElement = function(element) {\n  return createVNode(\n    element.nodeName.toLowerCase(),\n    EMPTY_OBJECT,\n    map.call(element.childNodes, recycleChild),\n    element,\n    null,\n    RECYCLED_NODE\n  )\n}\n\nexport var recycle = function(container) {\n  return recycleElement(container.children[0])\n}\n\nexport var patch = function(lastNode, nextNode, container) {\n  var lifecycle = []\n\n  patchElement(container, container.children[0], lastNode, nextNode, lifecycle)\n\n  while (lifecycle.length > 0) lifecycle.pop()()\n\n  return nextNode\n}\n\nexport var h = function(name, props) {\n  var node\n  var rest = []\n  var children = []\n  var length = arguments.length\n\n  while (length-- > 2) rest.push(arguments[length])\n\n  if ((props = props == null ? {} : props).children != null) {\n    if (rest.length <= 0) {\n      rest.push(props.children)\n    }\n    delete props.children\n  }\n\n  while (rest.length > 0) {\n    if (isArray((node = rest.pop()))) {\n      for (length = node.length; length-- > 0; ) {\n        rest.push(node[length])\n      }\n    } else if (node === false || node === true || node == null) {\n    } else {\n      children.push(typeof node === \"object\" ? node : createTextVNode(node))\n    }\n  }\n\n  return typeof name === \"function\"\n    ? name(props, (props.children = children))\n    : createVNode(name, props, children, null, props.key, DEFAULT)\n}\n","let Observable = (dataObj) => {\r\n    let signals = {}\r\n    let Dep = {\r\n        target: null,\r\n        subs:{},\r\n        depend (deps,dep){\r\n            if(!deps.includes(this.target)){\r\n                deps.push(this.target)\r\n            }\r\n            if(!Dep.subs[this.target].includes(dep)){\r\n                Dep.subs[this.target].push(dep)\r\n            }\r\n        },\r\n        getValidDeps (deps, key){\r\n            return deps.filter(dep => this.subs[dep].includes(key))\r\n        },\r\n        notifyDeps(deps){\r\n            //deps.forEach(notify)\r\n            deps.map( (sig) => notify(sig))\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Observe function\r\n     * \r\n     * @param {*} property \r\n     * @param {function} cb \r\n     */\r\n    let observe = (property, cb) => {\r\n        if(!signals[property]) signals[property] = []\r\n        signals[property].push(cb)  \r\n    }\r\n\r\n    let autorender = ()=>{\r\n        console.log('rerender')\r\n    }\r\n    \r\n    /**\r\n     * \r\n     * @param {object} obj \r\n     * @param {*} key \r\n     */\r\n    let makeReactive = (obj, key, computeFunc) => {\r\n        let val = obj[key]\r\n        let deps =[]\r\n    \r\n        Object.defineProperty(obj, key,{\r\n            get(){\r\n                if(Dep.target) {\r\n                   \r\n                    Dep.depend(deps,key)\r\n                    }\r\n                    return val       \r\n            },\r\n             set(newVal){\r\n                val = newVal\r\n                deps = Dep.getValidDeps(deps, key)\r\n                Dep.notifyDeps(deps, key)\r\n                notify(key)\r\n                autorender()\r\n                \r\n            }\r\n        })\r\n    }\r\n    \r\n    /**\r\n     * \r\n     * @param {object} obj \r\n     */\r\n    let observeData = (obj) =>{\r\n        for (let key in obj){\r\n            if( obj.hasOwnProperty(key)){\r\n                if(typeof obj[key] === 'function'){\r\n                    makeComputed(obj,key, obj[key])\r\n                } else{\r\n                    makeReactive(obj, key)\r\n                }      \r\n            }\r\n        }\r\n    }\r\n    \r\n    let notify = (signal) => {\r\n        if(!signals[signal] || signals[signal].lenght <1) return\r\n         \r\n         signals[signal].forEach( (signalHandler) => signalHandler() )\r\n    }\r\n    \r\n    let makeComputed = (obj, key, computeFunc) =>{\r\n        let cache = null\r\n        let deps = []\r\n        observe(key, ()=>{\r\n            cache = null //clear cache\r\n            deps = Dep.getValidDeps(deps,key)\r\n            Dep.notifyDeps(deps, key)\r\n        })\r\n    \r\n        Object.defineProperty(obj, key, {\r\n    \r\n            get() {\r\n                if(Dep.target) {\r\n                    Dep.depend(deps, key)\r\n                }\r\n                Dep.target = key\r\n    \r\n                if(!cache){\r\n                    Dep.subs[key] =[]\r\n                    cache = computeFunc.call(obj)\r\n                }\r\n                //Clear target context\r\n                Dep.target = null\r\n                return cache\r\n            },\r\n    \r\n            set(){/*Do nothing*/}\r\n        })\r\n    }\r\n    \r\n    let subscribeWatchers = (watchers, context) => {\r\n        for( let key in watchers){\r\n            if(watchers.hasOwnProperty(key)){\r\n                observe(key, watchers[key].bind(context))\r\n            }\r\n        }\r\n    }\r\n    \r\n    observeData(dataObj.data)\r\n    subscribeWatchers(dataObj.watch, dataObj.data)\r\n    \r\n    return {\r\n        state: dataObj.data,\r\n        observe,\r\n        notify\r\n    }\r\n    \r\n}\r\n    \r\n module.exports = {\r\n        Observable: Observable\r\n}","module.exports = function mapper (compileFn, options) {\n  if (typeof compileFn !== 'function') throw new Error('URL Mapper - function to compile a route expected as first argument')\n\n  options = options || {}\n  var cache = {}\n\n  function getCompiledRoute (route) {\n    if (!cache[route]) {\n      cache[route] = compileFn(route, options)\n    }\n\n    return cache[route]\n  }\n\n  function parse (route, url) {\n    if (arguments.length < 2) throw new Error('URL Mapper - parse method expects 2 arguments')\n    return getCompiledRoute(route).parse(url)\n  }\n\n  function stringify (route, values) {\n    if (arguments.length < 2) throw new Error('URL Mapper - stringify method expects 2 arguments')\n    return getCompiledRoute(route).stringify(values)\n  }\n\n  function map (url, routes) {\n    if (arguments.length < 2) throw new Error('URL Mapper - map method expects 2 arguments')\n    for (var route in routes) {\n      var compiled = getCompiledRoute(route)\n      var values = compiled.parse(url)\n      if (values) {\n        var match = routes[route]\n\n        return {\n          route: route,\n          match: match,\n          values: values\n        }\n      }\n    }\n  }\n\n  return {\n    parse: parse,\n    stringify: stringify,\n    map: map\n  }\n}\n","/* eslint-disable no-labels */\n'use strict'\n\nvar keyStringifyRegexp = /([=:@$/])/g\nvar valueStringifyRegexp = /([&;/])/g\nvar keyParseRegexp = /[=:@$]/\nvar valueParseRegexp = /[&;]/\n\nfunction encodeString (str, regexp) {\n  return encodeURI(str.replace(regexp, '/$1'))\n}\n\nfunction trim (res) {\n  return typeof res === 'string' ? res.replace(/;+$/g, '') : res\n}\n\nfunction stringify (input, recursive) {\n  if (!recursive) {\n    return trim(stringify(input, true))\n  }\n  // Number, Boolean or Null\n  if (\n    typeof input === 'number' ||\n    input === true ||\n    input === false ||\n    input === null\n  ) {\n    return ':' + input\n  }\n  var res = []\n  // Array\n  if (input instanceof Array) {\n    for (var i = 0; i < input.length; ++i) {\n      typeof input[i] === 'undefined'\n        ? res.push(':null')\n        : res.push(stringify(input[i], true))\n    }\n    return '@' + res.join('&') + ';'\n  }\n  // Object\n  if (typeof input === 'object') {\n    for (var key in input) {\n      var val = stringify(input[key], true)\n      if (val) {\n        res.push(encodeString(key, keyStringifyRegexp) + val)\n      }\n    }\n    return '$' + res.join('&') + ';'\n  }\n  // undefined\n  if (typeof input === 'undefined') {\n    return\n  }\n  // String\n  return '=' + encodeString(input.toString(), valueStringifyRegexp)\n}\n\nfunction parse (str) {\n  var pos = 0\n  str = decodeURI(str)\n\n  function readToken (regexp) {\n    var token = ''\n    for (; pos !== str.length; ++pos) {\n      if (str.charAt(pos) === '/') {\n        pos += 1\n        if (pos === str.length) {\n          token += ';'\n          break\n        }\n      } else if (str.charAt(pos).match(regexp)) {\n        break\n      }\n      token += str.charAt(pos)\n    }\n    return token\n  }\n\n  function parseToken () {\n    var type = str.charAt(pos++)\n    // String\n    if (type === '=') {\n      return readToken(valueParseRegexp)\n    }\n    // Number, Boolean or Null\n    if (type === ':') {\n      var value = readToken(valueParseRegexp)\n      if (value === 'true') {\n        return true\n      }\n      if (value === 'false') {\n        return false\n      }\n      value = parseFloat(value)\n      return isNaN(value) ? null : value\n    }\n    var res\n    // Array\n    if (type === '@') {\n      res = []\n      loop: {\n        // empty array\n        if (pos >= str.length || str.charAt(pos) === ';') {\n          break loop\n        }\n        // parse array items\n        while (1) {\n          res.push(parseToken())\n          if (pos >= str.length || str.charAt(pos) === ';') {\n            break loop\n          }\n          pos += 1\n        }\n      }\n      pos += 1\n      return res\n    }\n    // Object\n    if (type === '$') {\n      res = {}\n      loop: {\n        if (pos >= str.length || str.charAt(pos) === ';') {\n          break loop\n        }\n        while (1) {\n          var name = readToken(keyParseRegexp)\n          res[name] = parseToken()\n          if (pos >= str.length || str.charAt(pos) === ';') {\n            break loop\n          }\n          pos += 1\n        }\n      }\n      pos += 1\n      return res\n    }\n    // Error\n    throw new Error('Unexpected char ' + type)\n  }\n\n  return parseToken()\n}\n\nmodule.exports = {\n  stringify: stringify,\n  parse: parse\n}\n","/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * Default configs.\n */\nvar DEFAULT_DELIMITER = '/'\nvar DEFAULT_DELIMITERS = './'\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \":test(\\\\d+)?\" => [\"test\", \"\\d+\", undefined, \"?\"]\n  // \"(\\\\d+)\"  => [undefined, undefined, \"\\d+\", undefined]\n  '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER\n  var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS\n  var pathEscaped = false\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) !== null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      pathEscaped = true\n      continue\n    }\n\n    var prev = ''\n    var next = str[index]\n    var name = res[2]\n    var capture = res[3]\n    var group = res[4]\n    var modifier = res[5]\n\n    if (!pathEscaped && path.length) {\n      var k = path.length - 1\n\n      if (delimiters.indexOf(path[k]) > -1) {\n        prev = path[k]\n        path = path.slice(0, k)\n      }\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n      pathEscaped = false\n    }\n\n    var partial = prev !== '' && next !== undefined && next !== prev\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = prev || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prev,\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'\n    })\n  }\n\n  // Push any remaining characters.\n  if (path || index < str.length) {\n    tokens.push(path + str.substr(index))\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (data, options) {\n    var path = ''\n    var encode = (options && options.encode) || encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n        continue\n      }\n\n      var value = data ? data[token.name] : undefined\n      var segment\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got array')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) continue\n\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j], token)\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        segment = encode(String(value), token)\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"')\n        }\n\n        path += token.prefix + segment\n        continue\n      }\n\n      if (token.optional) {\n        // Prepend partial segment prefixes.\n        if (token.partial) path += token.prefix\n\n        continue\n      }\n\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + (token.repeat ? 'an array' : 'a string'))\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {Array=}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  if (!keys) return path\n\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        pattern: null\n      })\n    }\n  }\n\n  return path\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options))\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}  tokens\n * @param  {Array=}  keys\n * @param  {Object=} options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var start = options.start !== false\n  var end = options.end !== false\n  var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER)\n  var delimiters = options.delimiters || DEFAULT_DELIMITERS\n  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|')\n  var route = start ? '^' : ''\n  var isEndDelimited = tokens.length === 0\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n      isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1\n    } else {\n      var capture = token.repeat\n        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'\n        : token.pattern\n\n      if (keys) keys.push(token)\n\n      if (token.optional) {\n        if (token.partial) {\n          route += escapeString(token.prefix) + '(' + capture + ')?'\n        } else {\n          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?'\n        }\n      } else {\n        route += escapeString(token.prefix) + '(' + capture + ')'\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += '(?:' + delimiter + ')?'\n\n    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')'\n  } else {\n    if (!strict) route += '(?:' + delimiter + '(?=' + endsWith + '))?'\n    if (!isEndDelimited) route += '(?=' + delimiter + '|' + endsWith + ')'\n  }\n\n  return new RegExp(route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {Array=}                keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys)\n  }\n\n  if (Array.isArray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), keys, options)\n}\n","'use strict'\nvar URLON = require('urlon')\nvar pathToRegexp = require('path-to-regexp')\n\nfunction getKeyName (key) {\n  return key.name.toString()\n}\n\n// loose escaping for segment part\n// see: https://github.com/pillarjs/path-to-regexp/pull/75\nfunction encodeSegment (str) {\n  return encodeURI(str).replace(/[/?#'\"]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\nfunction compileRoute (route, options) {\n  var re\n  var compiled\n  var keys = []\n  var querySeparator = options.querySeparator || '?'\n\n  re = pathToRegexp(route, keys)\n  keys = keys.map(getKeyName)\n  compiled = pathToRegexp.compile(route)\n\n  return {\n    parse: function (url) {\n      var path = url\n      var result = {}\n\n      if (~path.indexOf('#') && !~querySeparator.indexOf('#')) {\n        path = path.split('#')[0]\n      }\n\n      if (~path.indexOf(querySeparator)) {\n        if (options.query) {\n          var queryString = '$' + path.slice(path.indexOf(querySeparator) + querySeparator.length)\n          result = URLON.parse(queryString)\n        }\n        path = path.split(querySeparator)[0]\n      }\n\n      var match = re.exec(path)\n      if (!match) return null\n\n      for (var i = 1; i < match.length; ++i) {\n        var key = keys[i - 1]\n        var value = match[i] && decodeURIComponent(match[i])\n        result[key] = (value && value[0] === ':')\n          ? URLON.parse(value)\n          : value\n      }\n\n      return result\n    },\n\n    stringify: function (values) {\n      var pathParams = {}\n      var queryParams = {}\n\n      Object.keys(values).forEach(function (key) {\n        if (~keys.indexOf(key)) {\n          switch (typeof values[key]) {\n            case 'boolean':\n            case 'number':\n              pathParams[key] = URLON.stringify(values[key])\n              break\n\n            case 'object':\n              if (values[key]) {\n                throw new Error('URL Mapper - objects are not allowed to be stringified as part of path')\n              } else { // null\n                pathParams[key] = URLON.stringify(values[key])\n              }\n              break\n\n            default:\n              pathParams[key] = values[key]\n          }\n        } else {\n          queryParams[key] = values[key]\n        }\n      })\n\n      var path = compiled(pathParams, { encode: encodeSegment })\n      var queryString = ''\n\n      if (options.query) {\n        if (Object.keys(queryParams).length) {\n          queryString = URLON.stringify(queryParams).slice(1)\n        }\n      }\n\n      return path + (queryString ? querySeparator + queryString : '')\n    }\n  }\n}\n\nmodule.exports = compileRoute\n","'use strict'\nvar mapper = require('./mapper')\nvar compileRoute = require('./compileRoute')\n\nmodule.exports = function urlMapper (options) {\n  return mapper(compileRoute, options)\n}\n","import {Observable} from './model'\r\nimport Mapper from 'url-mapper'\r\n\r\nconst urlMapper = Mapper()\r\n\r\nlet router = (routes) => loc  => {\r\n    var matchedRoute = urlMapper.map(loc,routes)\r\n    return (matchedRoute)\r\n}\r\n\r\n\r\nmodule.exports = {\r\n    router: router\r\n}","import {patch, h} from 'superfine'\r\nimport {Observable} from './libs/model'\r\nimport {router} from './libs/router'\r\n\r\nconst Render = (view, container, node) => state => {\r\n    node = patch(node, view(state), container)\r\n}\r\n\r\n\r\n\r\nmodule.exports = {\r\n    h: h,\r\n    patch: patch,\r\n    Observable: Observable,\r\n    Render: Render,\r\n    Router: router\r\n}"]}